
==================== FINAL INTERFACE ====================
2019-05-20 17:36:12.9239765 UTC

interface exercism-clock-2.3.0.8-BGUQ0ojAQKwH6k6huJ1Q0m:Clock 8043
  interface hash: e849a8bf785096168783b9ed954626ae
  ABI hash: 8574af06d086759483475a68daf45550
  export-list hash: abc47ef029f37e2252765802431db2f1
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 0527c515cada2cc2079fef10aa370e66
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Clock.addDelta
  Clock.fromHourMin
  Clock.toString
module dependencies:
package dependencies: base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:GHC.Base b7dd14d8fe8d606dde5678ea6b0575e9
import  -/  base-4.11.1.0:GHC.Num 5de8df0185e7e8d8ec29b3c61e2c8606
import  -/  base-4.11.1.0:GHC.Real 032ed0a1053f878238d78e95e75f2edf
import  -/  base-4.11.1.0:GHC.Show 6211aec7cccd267a5ee999e4414d7b90
import  -/  base-4.11.1.0:Prelude aca391812f777207b15d62bb5b9feb63
import  -/  ghc-prim-0.5.2.0:GHC.Classes f7d67fd97d5a20e9252c9597d1aa387b
33cb60bc4683e0fb75d16e2e069f8aa4
  $fEqClock :: GHC.Classes.Eq Clock.Clock
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Clock.Clock Clock.$fEqClock_$c== Clock.$fEqClock_$c/= -}
33cb60bc4683e0fb75d16e2e069f8aa4
  $fEqClock_$c/= :: Clock.Clock -> Clock.Clock -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Clock.Clock) (y :: Clock.Clock) ->
                 case x of wild { Clock.Clock a1 a2 ->
                 case y of wild1 { Clock.Clock b1 b2 ->
                 case GHC.Classes.eqInt a1 b1 of wild2 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.eqInt a2 b2 of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
33cb60bc4683e0fb75d16e2e069f8aa4
  $fEqClock_$c== :: Clock.Clock -> Clock.Clock -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Clock.Clock) (w1 :: Clock.Clock) ->
                 case w of ww { Clock.Clock ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Clock.Clock ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Clock.$w$c== ww4 ww2 ww9 ww7 } } } }) -}
33cb60bc4683e0fb75d16e2e069f8aa4
  $fShowClock :: GHC.Show.Show Clock.Clock
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Clock.Clock
                  Clock.$fShowClock_$cshowsPrec
                  Clock.$fShowClock_$cshow
                  Clock.$fShowClock_$cshowList -}
33cb60bc4683e0fb75d16e2e069f8aa4
  $fShowClock1 :: Clock.Clock -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(1*U(U),1*U(U))><L,U>,
     Unfolding: (\ (w :: Clock.Clock) (w1 :: GHC.Base.String) ->
                 case w of ww { Clock.Clock ww1 ww2 ->
                 Clock.$w$cshowsPrec 0# ww1 ww2 w1 }) -}
14d98c38e98231b8c426af28d118f34e
  $fShowClock2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("}"#) -}
18203dc1f23f8966e2420bb733640f9a
  $fShowClock3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("m = "#) -}
b1218fce4f2434901fb5794137880bf2
  $fShowClock4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("h = "#) -}
7b4b951b79afb3a399529e425300dc48
  $fShowClock5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Clock.$fShowClock6) -}
0b33e28af27e260414c6cc37157e9aa9
  $fShowClock6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Clock {"#) -}
f7490e396630d906336a8396462596c3
  $fShowClock7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Clock.$fShowClock2) -}
33cb60bc4683e0fb75d16e2e069f8aa4
  $fShowClock_$cshow :: Clock.Clock -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U))>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Clock.Clock) ->
                 case w of ww { Clock.Clock ww1 ww2 -> Clock.$w$cshow ww1 ww2 }) -}
33cb60bc4683e0fb75d16e2e069f8aa4
  $fShowClock_$cshowList :: [Clock.Clock] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Clock.Clock]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Clock.Clock Clock.$fShowClock1 ls s) -}
33cb60bc4683e0fb75d16e2e069f8aa4
  $fShowClock_$cshowsPrec ::
    GHC.Types.Int -> Clock.Clock -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U(U),1*U(U))><L,U>,
     Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Clock.Clock)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Clock.Clock ww3 ww4 ->
                 Clock.$w$cshowsPrec ww1 ww3 ww4 w2 } }) -}
03bb7cfa2015b7487d25fb3d57d25921
  $tc'Clock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17370257292867342948##
                   4174633874759148057##
                   Clock.$trModule
                   Clock.$tc'Clock2
                   0#
                   Clock.$tc'Clock1) -}
0055b137879badd77b96c047f372ea19
  $tc'Clock1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
cce188516f2163f12351d43f7d779124
  $tc'Clock2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Clock.$tc'Clock3) -}
29ccca1055c99dd5e79f4b8107d72a99
  $tc'Clock3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Clock"#) -}
bd427a9613bd64e2ca2e721b0065b9ea
  $tcClock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1417178276056352223##
                   6833330150775471887##
                   Clock.$trModule
                   Clock.$trModule1
                   0#
                   GHC.Types.krep$*) -}
c33c8c2e55ff431c7ac7674bb4b47fb6
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Clock.$trModule3 Clock.$trModule1) -}
11bde8bb7a90f3d17465be113e254e39
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Clock.$trModule2) -}
81495d3d49ae8f5cd9000c2a0eb13764
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Clock"#) -}
99a508531b39d63d2fd25acdb2c43052
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Clock.$trModule4) -}
519288f0e59a9a294a770d3ffdc8df57
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("exercism-clock-2.3.0.8-BGUQ0ojAQKwH6k6huJ1Q0m"#) -}
4ffa7bcfa4758726493a2730e2e020ca
  $w$c== ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.==# ww ww2 of lwild {
                   DEFAULT -> GHC.Types.False 1# -> GHC.Classes.eqInt ww1 ww3 }) -}
7186043046e982dc18e76a0f7da5ec52
  $w$cshow :: GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(U)><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Types.Int) (ww1 :: GHC.Types.Int) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   Clock.$fShowClock5
                   (GHC.CString.unpackAppendCString#
                      Clock.$fShowClock4
                      (case ww of ww2 { GHC.Types.I# ww3 ->
                       case GHC.Show.$wshowSignedInt
                              0#
                              ww3
                              (GHC.Base.++
                                 @ GHC.Types.Char
                                 GHC.Show.showCommaSpace1
                                 (GHC.CString.unpackAppendCString#
                                    Clock.$fShowClock3
                                    (case ww1 of ww5 { GHC.Types.I# ww6 ->
                                     case GHC.Show.$wshowSignedInt
                                            0#
                                            ww6
                                            Clock.$fShowClock7 of ww4 { (#,#) ww7 ww8 ->
                                     GHC.Types.:
                                       @ GHC.Types.Char
                                       ww7
                                       ww8 } }))) of ww4 { (#,#) ww5 ww6 ->
                       GHC.Types.: @ GHC.Types.Char ww5 ww6 } }))) -}
71063b30603bbb7dbfcdc8b521b9e36d
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*U(U)><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int)
                   (w :: GHC.Base.String) ->
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Clock.$fShowClock5
                        (GHC.CString.unpackAppendCString#
                           Clock.$fShowClock4
                           (case ww1 of ww3 { GHC.Types.I# ww4 ->
                            case GHC.Show.$wshowSignedInt
                                   0#
                                   ww4
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      GHC.Show.showCommaSpace1
                                      (GHC.CString.unpackAppendCString#
                                         Clock.$fShowClock3
                                         (case ww2 of ww5 { GHC.Types.I# ww6 ->
                                          case GHC.Show.$wshowSignedInt
                                                 0#
                                                 ww6
                                                 (GHC.CString.unpackAppendCString#
                                                    Clock.$fShowClock2
                                                    w) of ww7 { (#,#) ww8 ww9 ->
                                          GHC.Types.:
                                            @ GHC.Types.Char
                                            ww8
                                            ww9 } }))) of ww5 { (#,#) ww6 ww7 ->
                            GHC.Types.: @ GHC.Types.Char ww6 ww7 } }))
                   1#
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Clock.$fShowClock5
                           (GHC.CString.unpackAppendCString#
                              Clock.$fShowClock4
                              (case ww1 of ww3 { GHC.Types.I# ww4 ->
                               case GHC.Show.$wshowSignedInt
                                      0#
                                      ww4
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         GHC.Show.showCommaSpace1
                                         (GHC.CString.unpackAppendCString#
                                            Clock.$fShowClock3
                                            (case ww2 of ww5 { GHC.Types.I# ww6 ->
                                             case GHC.Show.$wshowSignedInt
                                                    0#
                                                    ww6
                                                    (GHC.CString.unpackAppendCString#
                                                       Clock.$fShowClock2
                                                       (GHC.Types.:
                                                          @ GHC.Types.Char
                                                          GHC.Show.$fShow(,)2
                                                          w)) of ww7 { (#,#) ww8 ww9 ->
                                             GHC.Types.:
                                               @ GHC.Types.Char
                                               ww8
                                               ww9 } }))) of ww5 { (#,#) ww6 ww7 ->
                               GHC.Types.: @ GHC.Types.Char ww6 ww7 } }))) }) -}
b8cda41069d970a68af616168c9d547e
  $waddDelta ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> Clock.Clock
    -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U)><L,1*U(U)><L,U(1*U(U),1*U(U))>, Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Clock.Clock) ->
                 Clock.$wfromHourMin
                   (case w of wild { GHC.Types.I# x ->
                    case w2 of wild1 { Clock.Clock ds ds1 ->
                    case ds of wild2 { GHC.Types.I# y ->
                    GHC.Types.I# (GHC.Prim.+# x y) } } })
                   (case w1 of wild { GHC.Types.I# x ->
                    case w2 of wild1 { Clock.Clock ds ds1 ->
                    case ds1 of wild2 { GHC.Types.I# y ->
                    GHC.Types.I# (GHC.Prim.+# x y) } } })) -}
260137eced7f27972123d7eb6c3c9cf9
  $wfromHourMin ::
    GHC.Types.Int
    -> GHC.Types.Int -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U(U)>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Int) ->
                 (# case w of wild { GHC.Types.I# x ->
                    case w1 of ww { GHC.Types.I# ww1 ->
                    case GHC.Classes.divInt# ww1 60# of ww4 { DEFAULT ->
                    case GHC.Classes.modInt#
                           (GHC.Prim.+# x ww4)
                           24# of ww2 { DEFAULT ->
                    GHC.Types.I# ww2 } } } },
                    case w1 of wild1 { GHC.Types.I# x ->
                    case GHC.Classes.modInt# x 60# of ww2 { DEFAULT ->
                    GHC.Types.I# ww2 } } #)) -}
37beea8df5a8619e4d0e6a63cb702df9
  $wtoString :: GHC.Prim.Int# -> GHC.Types.Int -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (ww1 :: GHC.Types.Int) ->
                 let {
                   n :: [GHC.Types.Char]
                   = GHC.CString.unpackAppendCString#
                       Clock.toString2
                       (case ww1 of wild { GHC.Types.I# x ->
                        case GHC.Prim.<# x 10# of lwild {
                          DEFAULT
                          -> case GHC.Show.$wshowSignedInt
                                    0#
                                    x
                                    (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                             GHC.Types.: @ GHC.Types.Char ww5 ww6 }
                          1#
                          -> GHC.CString.unpackAppendCString#
                               Clock.toString1
                               (case GHC.Show.$wshowSignedInt
                                       0#
                                       x
                                       (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                GHC.Types.: @ GHC.Types.Char ww5 ww6 }) } })
                 } in
                 case GHC.Prim.<# ww 10# of lwild {
                   DEFAULT
                   -> case GHC.Show.$wshowSignedInt
                             0#
                             ww
                             (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                      GHC.Base.++_$s++ @ GHC.Types.Char n ww5 ww6 }
                   1#
                   -> GHC.CString.unpackAppendCString#
                        Clock.toString1
                        (case GHC.Show.$wshowSignedInt
                                0#
                                ww
                                (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                         GHC.Base.++_$s++ @ GHC.Types.Char n ww5 ww6 }) }) -}
33cb60bc4683e0fb75d16e2e069f8aa4
  data Clock = Clock {h :: GHC.Types.Int, m :: GHC.Types.Int}
6c38da43c684aab9a47f0002a61e3b9e
  addDelta ::
    GHC.Types.Int -> GHC.Types.Int -> Clock.Clock -> Clock.Clock
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(U)><L,1*U(U)><L,U(U(U),U(U))>m, Inline: [0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Clock.Clock) ->
                 case Clock.$waddDelta w w1 w2 of ww { (#,#) ww1 ww2 ->
                 Clock.Clock ww1 ww2 }) -}
f3e0cc5d7af44a5fce0224b9ef940c8a
  fromHourMin :: GHC.Types.Int -> GHC.Types.Int -> Clock.Clock
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,U(U)>m,
     Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Types.Int) ->
                 case Clock.$wfromHourMin w w1 of ww { (#,#) ww1 ww2 ->
                 Clock.Clock ww1 ww2 }) -}
33cb60bc4683e0fb75d16e2e069f8aa4
  h :: Clock.Clock -> GHC.Types.Int
  RecSel Left Clock.Clock
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Clock.Clock) ->
                 case ds of wild { Clock.Clock ds1 ds2 -> ds1 }) -}
33cb60bc4683e0fb75d16e2e069f8aa4
  m :: Clock.Clock -> GHC.Types.Int
  RecSel Left Clock.Clock
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Clock.Clock) ->
                 case ds of wild { Clock.Clock ds1 ds2 -> ds2 }) -}
3b96697937b395f97458dc7932bdc788
  toString :: Clock.Clock -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Clock.Clock) ->
                 case w of ww { Clock.Clock ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 Clock.$wtoString ww4 ww2 } }) -}
1a0a5318257899d3f54dfebb04cefd1b
  toString1 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("0"#) -}
e6b89d8a260dffdcacbb247e11b2e277
  toString2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (":"#) -}
instance [safe] GHC.Classes.Eq [Clock.Clock] = Clock.$fEqClock
instance [safe] GHC.Show.Show [Clock.Clock] = Clock.$fShowClock
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

