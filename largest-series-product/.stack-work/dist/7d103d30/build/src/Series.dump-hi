
==================== FINAL INTERFACE ====================
2019-08-25 16:42:02.0225454 UTC

interface largest-series-product-1.2.0.6-FjLwq3sGHuWA5lpwW6djT7:Series 8043
  interface hash: 059ffa66da483763e696c462d60aee23
  ABI hash: 61c2f0a65b468b9c61b1776d75d4c496
  export-list hash: c7853c33cafd06343194d8cf0fff29e3
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 0527c515cada2cc2079fef10aa370e66
  opt_hash: 14e536840aca4e889cad654e6f9b79c1
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  sig of: Nothing
  used TH splices: False
  where
exports:
  Series.largestProduct
  Series.Error{Series.InvalidDigit Series.InvalidSpan}
module dependencies:
package dependencies: base-4.11.1.0* ghc-prim-0.5.2.0
                      integer-gmp-1.0.2.0
orphans: base-4.11.1.0:GHC.Float base-4.11.1.0:GHC.Base
family instance modules: base-4.11.1.0:Control.Applicative
                         base-4.11.1.0:Data.Functor.Const
                         base-4.11.1.0:Data.Functor.Identity base-4.11.1.0:Data.Monoid
                         base-4.11.1.0:Data.Semigroup.Internal base-4.11.1.0:GHC.Generics
                         base-4.11.1.0:GHC.IO.Exception
import  -/  base-4.11.1.0:Data.Char c550369827d719df8be8fb1e8cd699c1
import  -/  base-4.11.1.0:Data.Either 917cb7ca74324934e13727e32d71d117
import  -/  base-4.11.1.0:Data.Foldable 6cf3e918f22d03c0870804f05cd183d1
import  -/  base-4.11.1.0:Data.List cb78ca5eace70fd310936fda86b3e611
import  -/  base-4.11.1.0:Data.OldList 3987872d5de68d40c22cd1c30825ad08
import  -/  base-4.11.1.0:GHC.Base b7dd14d8fe8d606dde5678ea6b0575e9
import  -/  base-4.11.1.0:GHC.List 95910b50fba2204d1a3364fe070ebf2b
import  -/  base-4.11.1.0:GHC.Num 5de8df0185e7e8d8ec29b3c61e2c8606
import  -/  base-4.11.1.0:GHC.Show 6211aec7cccd267a5ee999e4414d7b90
import  -/  base-4.11.1.0:GHC.Unicode 875b8e8d21ca0bd8abbb7bede4488443
import  -/  base-4.11.1.0:Prelude aca391812f777207b15d62bb5b9feb63
import  -/  base-4.11.1.0:Text.Read 5c288a0919cb418cf58278e23fdb845d
import  -/  ghc-prim-0.5.2.0:GHC.Classes f7d67fd97d5a20e9252c9597d1aa387b
94308bb1e4283cfe75594cc6cf9c19b7
  $fEqError :: GHC.Classes.Eq Series.Error
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Series.Error Series.$fEqError_$c== Series.$fEqError_$c/= -}
94308bb1e4283cfe75594cc6cf9c19b7
  $fEqError_$c/= :: Series.Error -> Series.Error -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Series.Error) (y :: Series.Error) ->
                 case x of wild {
                   Series.InvalidSpan
                   -> case y of wild1 {
                        Series.InvalidSpan -> GHC.Types.False
                        Series.InvalidDigit ipv -> GHC.Types.True }
                   Series.InvalidDigit a1
                   -> case y of wild1 {
                        Series.InvalidSpan -> GHC.Types.True
                        Series.InvalidDigit b1
                        -> case GHC.Classes.eqChar a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True -> GHC.Types.False } } }) -}
94308bb1e4283cfe75594cc6cf9c19b7
  $fEqError_$c== :: Series.Error -> Series.Error -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Series.Error) (ds1 :: Series.Error) ->
                 case ds of wild {
                   Series.InvalidSpan
                   -> case ds1 of wild1 {
                        Series.InvalidSpan -> GHC.Types.True
                        Series.InvalidDigit ipv -> GHC.Types.False }
                   Series.InvalidDigit a1
                   -> case ds1 of wild1 {
                        Series.InvalidSpan -> GHC.Types.False
                        Series.InvalidDigit b1 -> GHC.Classes.eqChar a1 b1 } }) -}
94308bb1e4283cfe75594cc6cf9c19b7
  $fShowError :: GHC.Show.Show Series.Error
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ Series.Error
                  Series.$fShowError_$cshowsPrec
                  Series.$fShowError_$cshow
                  Series.$fShowError_$cshowList -}
94308bb1e4283cfe75594cc6cf9c19b7
  $fShowError1 :: Series.Error -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Series.$fShowError_$cshowsPrec Series.$fShowError2) -}
675915cefba310b03d891d97df76f67b
  $fShowError2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
5aca8fc581c3d10c010b0a255b4ea6c4
  $fShowError3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("InvalidDigit "#) -}
42f8c1cf7b07547e49d3210b490ad9c0
  $fShowError4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Series.$fShowError5) -}
91a91a9bf111c578178d6ab9cde1d76d
  $fShowError5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("InvalidSpan"#) -}
94308bb1e4283cfe75594cc6cf9c19b7
  $fShowError_$cshow :: Series.Error -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Series.Error) ->
                 case x of wild {
                   Series.InvalidSpan -> Series.$fShowError4
                   Series.InvalidDigit b1
                   -> GHC.CString.unpackAppendCString#
                        Series.$fShowError3
                        (case b1 of ww { GHC.Types.C# ww1 ->
                         GHC.Show.$w$cshowsPrec3
                           ww1
                           (GHC.Types.[] @ GHC.Types.Char) }) }) -}
94308bb1e4283cfe75594cc6cf9c19b7
  $fShowError_$cshowList :: [Series.Error] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Series.Error]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Series.Error Series.$fShowError1 ls s) -}
94308bb1e4283cfe75594cc6cf9c19b7
  $fShowError_$cshowsPrec ::
    GHC.Types.Int -> Series.Error -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (ds :: GHC.Types.Int)
                   (ds1 :: Series.Error)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Series.InvalidSpan
                   -> GHC.Base.++ @ GHC.Types.Char Series.$fShowError4 eta
                   Series.InvalidDigit b1
                   -> case ds of wild1 { GHC.Types.I# x ->
                      case GHC.Prim.>=# x 11# of lwild {
                        DEFAULT
                        -> GHC.CString.unpackAppendCString#
                             Series.$fShowError3
                             (case b1 of ww { GHC.Types.C# ww1 ->
                              GHC.Show.$w$cshowsPrec3 ww1 eta })
                        1#
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.$fShow(,)4
                             (GHC.CString.unpackAppendCString#
                                Series.$fShowError3
                                (case b1 of ww { GHC.Types.C# ww1 ->
                                 GHC.Show.$w$cshowsPrec3
                                   ww1
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.$fShow(,)2
                                      eta) })) } } }) -}
bcec1a9ffa3884e54a233061b3edf9f9
  $tc'InvalidDigit :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   936835325437874895##
                   6260732631089487713##
                   Series.$trModule
                   Series.$tc'InvalidDigit2
                   0#
                   Series.$tc'InvalidDigit1) -}
87a2ab83a2ba355331af2e115e016d48
  $tc'InvalidDigit1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
ab274dd2bed8fd94da038e23d33b6d93
  $tc'InvalidDigit2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Series.$tc'InvalidDigit3) -}
599901409d6b9e66d2527a372d83dfb9
  $tc'InvalidDigit3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'InvalidDigit"#) -}
019438a917799068e11612e95efc4ae0
  $tc'InvalidSpan :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13407444986420201390##
                   4674473882665792479##
                   Series.$trModule
                   Series.$tc'InvalidSpan2
                   0#
                   Series.$tc'InvalidSpan1) -}
1d698bebf782da4b6621362945313b5e
  $tc'InvalidSpan1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m1, Inline: [~] -}
7717dacd8316158650098610245a9a6f
  $tc'InvalidSpan2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Series.$tc'InvalidSpan3) -}
38f669109f1e34b8dadcbe47cf5dcc3b
  $tc'InvalidSpan3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'InvalidSpan"#) -}
496b6d16bf96debe49246e54dcb50725
  $tcError :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10691132557443668803##
                   796046244165409541##
                   Series.$trModule
                   Series.$tcError1
                   0#
                   GHC.Types.krep$*) -}
83d301fec5e9210944e1e8afed463368
  $tcError1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Series.$tcError2) -}
d7e485538d6d7060c6e9dfdf4918d7be
  $tcError2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Error"#) -}
694c8717f9f548b7fb2855790ef1e775
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Series.$trModule3
                   Series.$trModule1) -}
e9a5250305d6bdd9eb7c2242c1b68b14
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Series.$trModule2) -}
0fd49dc347f83cdfe9caa5bb34075e1a
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Series"#) -}
971538b554d5f70239c13fb36d644148
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Series.$trModule4) -}
526efa830452de299e69163e3b8fc06c
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("largest-series-product-1.2.0.6-FjLwq3sGHuWA5lpwW6djT7"#) -}
6860144f00bbd1b235a7440ee1175f6c
  $wgo ::
    [GHC.Types.Int] -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><S,U>,
     Inline: [0] -}
b22ce6dc9609ea6ba875a0821c03ce74
  $wlargestProduct ::
    GHC.Prim.Int#
    -> GHC.Base.String -> Data.Either.Either Series.Error GHC.Types.Int
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: GHC.Base.String) ->
                 case GHC.Prim.<# ww 0# of lwild {
                   DEFAULT
                   -> case ww of wild {
                        DEFAULT
                        -> case GHC.List.$wlenAcc @ GHC.Types.Char w 0# of ww2 { DEFAULT ->
                           case GHC.Prim.<=# wild ww2 of lwild1 {
                             DEFAULT -> Series.largestProduct7
                             1#
                             -> let {
                                  $j :: Data.Either.Either Series.Error GHC.Types.Int <join 0>
                                  = Data.Either.Right
                                      @ Series.Error
                                      @ GHC.Types.Int
                                      (let {
                                         y :: GHC.Prim.Int# = GHC.Prim.+# (GHC.Prim.-# ww2 wild) 1#
                                       } in
                                       case GHC.Prim.<# 0# y of lwild2 {
                                         DEFAULT -> GHC.List.maximum2
                                         1#
                                         -> let {
                                              lvl :: GHC.Types.Bool
                                              = GHC.Prim.tagToEnum#
                                                  @ GHC.Types.Bool
                                                  (GHC.Prim.<# 0# wild)
                                            } in
                                            letrec {
                                              $wtailsGo :: [GHC.Types.Int]
                                                           -> GHC.Prim.Int# -> [GHC.Types.Int]
                                                {- Arity: 2, Strictness: <L,U><S,1*U>,
                                                   Inline: [0] -}
                                              = \ (w1 :: [GHC.Types.Int]) (ww1 :: GHC.Prim.Int#) ->
                                                case ww1 of ds1 {
                                                  DEFAULT
                                                  -> GHC.Types.:
                                                       @ GHC.Types.Int
                                                       (case lvl of wild1 {
                                                          GHC.Types.False -> GHC.Types.I# 1#
                                                          GHC.Types.True
                                                          -> case Series.$wgo
                                                                    w1
                                                                    wild
                                                                    1# of ww3 { DEFAULT ->
                                                             GHC.Types.I# ww3 } })
                                                       (case w1 of wild1 {
                                                          [] -> GHC.Types.[] @ GHC.Types.Int
                                                          : ds xs'
                                                          -> $wtailsGo xs' (GHC.Prim.-# ds1 1#) })
                                                  1#
                                                  -> GHC.Types.:
                                                       @ GHC.Types.Int
                                                       (case lvl of wild1 {
                                                          GHC.Types.False -> GHC.Types.I# 1#
                                                          GHC.Types.True
                                                          -> case Series.$wgo
                                                                    w1
                                                                    wild
                                                                    1# of ww3 { DEFAULT ->
                                                             GHC.Types.I# ww3 } })
                                                       (GHC.Types.[] @ GHC.Types.Int) }
                                            } in
                                            case $wtailsGo
                                                   (GHC.Base.map
                                                      @ GHC.Types.Char
                                                      @ GHC.Types.Int
                                                      Series.largestProduct3
                                                      w)
                                                   y of wild1 {
                                              [] -> GHC.List.maximum2
                                              : ipv ipv1
                                              -> case ipv of ww1 { GHC.Types.I# ww3 ->
                                                 case GHC.List.$wgo ipv1 ww3 of ww4 { DEFAULT ->
                                                 GHC.Types.I# ww4 } } } })
                                } in
                                letrec {
                                  go :: [GHC.Types.Char]
                                        -> Data.Either.Either Series.Error GHC.Types.Int
                                    <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                                  = \ (ds :: [GHC.Types.Char]) ->
                                    case ds of wild1 {
                                      [] -> $j
                                      : y ys
                                      -> case y of wild2 { GHC.Types.C# c# ->
                                         case GHC.Prim.leWord#
                                                (GHC.Prim.int2Word#
                                                   (GHC.Prim.-# (GHC.Prim.ord# c#) 48#))
                                                9## of lwild2 {
                                           DEFAULT
                                           -> Data.Either.Left
                                                @ Series.Error
                                                @ GHC.Types.Int
                                                (Series.InvalidDigit wild2)
                                           1# -> go ys } } }
                                } in
                                go w } }
                        0# -> Series.largestProduct1 }
                   1# -> Series.largestProduct7 }) -}
94308bb1e4283cfe75594cc6cf9c19b7
  data Error = InvalidSpan | InvalidDigit GHC.Types.Char
21d888870193eddae982e2f2599904ab
  largestProduct ::
    GHC.Types.Int
    -> GHC.Base.String -> Data.Either.Either Series.Error GHC.Types.Int
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,U>, Inline: [0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Series.$wlargestProduct ww1 w1 }) -}
d7de2d19af5aa57e6d526448cb03c7f9
  largestProduct1 :: Data.Either.Either Series.Error GHC.Types.Int
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Data.Either.Right
                   @ Series.Error
                   @ GHC.Types.Int
                   Series.largestProduct2) -}
1f8475c6f107563d86d259024acc6fdb
  largestProduct2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
5571ad6c396d49f0838dd12b771a39d4
  largestProduct3 :: GHC.Types.Char -> GHC.Types.Int
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (x :: GHC.Types.Char) ->
                 case Text.Read.readEither8
                        @ GHC.Types.Int
                        (Text.ParserCombinators.ReadP.run
                           @ GHC.Types.Int
                           Series.largestProduct6
                           (GHC.Types.:
                              @ GHC.Types.Char
                              x
                              (GHC.Types.[] @ GHC.Types.Char))) of wild {
                   [] -> Series.largestProduct5
                   : x1 ds
                   -> case ds of wild1 {
                        [] -> x1 : ipv ipv1 -> Series.largestProduct4 } }) -}
00c51f0160f875c551a1a4c4c4cab834
  largestProduct4 :: GHC.Types.Int
  {- Strictness: x -}
de5874b145406ca81b77f1efea009cf7
  largestProduct5 :: GHC.Types.Int
  {- Strictness: x -}
ddb2a41a4e1a441fb693fac6c229b886
  largestProduct6 :: Text.ParserCombinators.ReadP.P GHC.Types.Int
  {- Unfolding: (GHC.Read.$fReadInt_$sreadNumber
                   GHC.Read.$fReadInt2
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Types.Int
                   (Text.Read.readEither7 @ GHC.Types.Int)) -}
132fbc3080f474cd7a3ecd438698601f
  largestProduct7 :: Data.Either.Either Series.Error GHC.Types.Int
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Data.Either.Left
                   @ Series.Error
                   @ GHC.Types.Int
                   Series.InvalidSpan) -}
instance [safe] GHC.Classes.Eq [Series.Error] = Series.$fEqError
instance [safe] GHC.Show.Show [Series.Error] = Series.$fShowError
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

